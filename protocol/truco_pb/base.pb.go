// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base.proto

package pbtruco

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PacketType int32

const (
	PacketType_TYPE_REQUEST  PacketType = 0
	PacketType_TYPE_RESPONSE PacketType = 1
)

var PacketType_name = map[int32]string{
	0: "TYPE_REQUEST",
	1: "TYPE_RESPONSE",
}

var PacketType_value = map[string]int32{
	"TYPE_REQUEST":  0,
	"TYPE_RESPONSE": 1,
}

func (x PacketType) String() string {
	return proto.EnumName(PacketType_name, int32(x))
}

func (PacketType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{0}
}

type ResponseType int32

const (
	ResponseType_TYPE_SUCCESS ResponseType = 0
	ResponseType_TYPE_FAIL    ResponseType = 1
)

var ResponseType_name = map[int32]string{
	0: "TYPE_SUCCESS",
	1: "TYPE_FAIL",
}

var ResponseType_value = map[string]int32{
	"TYPE_SUCCESS": 0,
	"TYPE_FAIL":    1,
}

func (x ResponseType) String() string {
	return proto.EnumName(ResponseType_name, int32(x))
}

func (ResponseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{1}
}

type RetCode int32

const (
	RetCode_SUCCESS           RetCode = 0
	RetCode_ERR_PKTILLEGAL    RetCode = 1
	RetCode_ERR_NOLOGIN       RetCode = 2
	RetCode_ERR_NOSUB         RetCode = 3
	RetCode_ERR_REPEATLOGIN   RetCode = 4
	RetCode_ERR_SIGN_ILLEGAL  RetCode = 5
	RetCode_ERR_ROOM_FINISHED RetCode = 6
	RetCode_ERR_UNKNOWN       RetCode = 99
)

var RetCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "ERR_PKTILLEGAL",
	2:  "ERR_NOLOGIN",
	3:  "ERR_NOSUB",
	4:  "ERR_REPEATLOGIN",
	5:  "ERR_SIGN_ILLEGAL",
	6:  "ERR_ROOM_FINISHED",
	99: "ERR_UNKNOWN",
}

var RetCode_value = map[string]int32{
	"SUCCESS":           0,
	"ERR_PKTILLEGAL":    1,
	"ERR_NOLOGIN":       2,
	"ERR_NOSUB":         3,
	"ERR_REPEATLOGIN":   4,
	"ERR_SIGN_ILLEGAL":  5,
	"ERR_ROOM_FINISHED": 6,
	"ERR_UNKNOWN":       99,
}

func (x RetCode) String() string {
	return proto.EnumName(RetCode_name, int32(x))
}

func (RetCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{2}
}

// 通用协议号
type Uri int32

const (
	// server to client
	Uri_PktBindRsp             Uri = 0
	Uri_PktHeartbeatRsp        Uri = 1
	Uri_PktKickRsp             Uri = 2
	Uri_PktLoadingRsp          Uri = 3
	Uri_PktPlayerInfoRsp       Uri = 4
	Uri_PktEmojiRsp            Uri = 5
	Uri_PktGameStartFailedRsp  Uri = 6
	Uri_PktGameStartRsp        Uri = 7
	Uri_PktPlayerOutRsp        Uri = 8
	Uri_PktGameWinRsp          Uri = 9
	Uri_PktGameSignError       Uri = 10
	Uri_PktGamePokerRsp        Uri = 11
	Uri_PktPlayerReLoginRsp    Uri = 12
	Uri_PktPlayerAddPokerRsp   Uri = 13
	Uri_PktPlayerOutPokerRsp   Uri = 14
	Uri_PktGameSuccessPokerRsp Uri = 15
	Uri_PktGameTakePokerRsp    Uri = 16
	Uri_PktGameHuPokerRsp      Uri = 17
	// client to server
	Uri_PktHeartbeatReq        Uri = 1000
	Uri_PktLoadingReq          Uri = 1001
	Uri_PktQuitReq             Uri = 1002
	Uri_PktEmojiReq            Uri = 1003
	Uri_PktGameOverReq         Uri = 1004
	Uri_PktGameAddPokerReq     Uri = 1005
	Uri_PktGameOutPokterReq    Uri = 1006
	Uri_PktGameSuccessPokerReq Uri = 1007
	Uri_PktGameTakePokerReq    Uri = 1008
	Uri_PktGameHuPokerReq      Uri = 1009
)

var Uri_name = map[int32]string{
	0:    "PktBindRsp",
	1:    "PktHeartbeatRsp",
	2:    "PktKickRsp",
	3:    "PktLoadingRsp",
	4:    "PktPlayerInfoRsp",
	5:    "PktEmojiRsp",
	6:    "PktGameStartFailedRsp",
	7:    "PktGameStartRsp",
	8:    "PktPlayerOutRsp",
	9:    "PktGameWinRsp",
	10:   "PktGameSignError",
	11:   "PktGamePokerRsp",
	12:   "PktPlayerReLoginRsp",
	13:   "PktPlayerAddPokerRsp",
	14:   "PktPlayerOutPokerRsp",
	15:   "PktGameSuccessPokerRsp",
	16:   "PktGameTakePokerRsp",
	17:   "PktGameHuPokerRsp",
	1000: "PktHeartbeatReq",
	1001: "PktLoadingReq",
	1002: "PktQuitReq",
	1003: "PktEmojiReq",
	1004: "PktGameOverReq",
	1005: "PktGameAddPokerReq",
	1006: "PktGameOutPokterReq",
	1007: "PktGameSuccessPokerReq",
	1008: "PktGameTakePokerReq",
	1009: "PktGameHuPokerReq",
}

var Uri_value = map[string]int32{
	"PktBindRsp":             0,
	"PktHeartbeatRsp":        1,
	"PktKickRsp":             2,
	"PktLoadingRsp":          3,
	"PktPlayerInfoRsp":       4,
	"PktEmojiRsp":            5,
	"PktGameStartFailedRsp":  6,
	"PktGameStartRsp":        7,
	"PktPlayerOutRsp":        8,
	"PktGameWinRsp":          9,
	"PktGameSignError":       10,
	"PktGamePokerRsp":        11,
	"PktPlayerReLoginRsp":    12,
	"PktPlayerAddPokerRsp":   13,
	"PktPlayerOutPokerRsp":   14,
	"PktGameSuccessPokerRsp": 15,
	"PktGameTakePokerRsp":    16,
	"PktGameHuPokerRsp":      17,
	"PktHeartbeatReq":        1000,
	"PktLoadingReq":          1001,
	"PktQuitReq":             1002,
	"PktEmojiReq":            1003,
	"PktGameOverReq":         1004,
	"PktGameAddPokerReq":     1005,
	"PktGameOutPokterReq":    1006,
	"PktGameSuccessPokerReq": 1007,
	"PktGameTakePokerReq":    1008,
	"PktGameHuPokerReq":      1009,
}

func (x Uri) String() string {
	return proto.EnumName(Uri_name, int32(x))
}

func (Uri) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{3}
}

type ReconnState int32

const (
	ReconnState_NOUSE         ReconnState = 0
	ReconnState_NO_PLAYERLIST ReconnState = 1
	ReconnState_NO_GAMESTART  ReconnState = 2
)

var ReconnState_name = map[int32]string{
	0: "NOUSE",
	1: "NO_PLAYERLIST",
	2: "NO_GAMESTART",
}

var ReconnState_value = map[string]int32{
	"NOUSE":         0,
	"NO_PLAYERLIST": 1,
	"NO_GAMESTART":  2,
}

func (x ReconnState) String() string {
	return proto.EnumName(ReconnState_name, int32(x))
}

func (ReconnState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{4}
}

type EmojiType int32

const (
	EmojiType_Emoticon    EmojiType = 0
	EmojiType_RegularText EmojiType = 1
	EmojiType_InputText   EmojiType = 2
)

var EmojiType_name = map[int32]string{
	0: "Emoticon",
	1: "RegularText",
	2: "InputText",
}

var EmojiType_value = map[string]int32{
	"Emoticon":    0,
	"RegularText": 1,
	"InputText":   2,
}

func (x EmojiType) String() string {
	return proto.EnumName(EmojiType_name, int32(x))
}

func (EmojiType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{5}
}

type WinState int32

const (
	WinState_NormalFinish    WinState = 0
	WinState_UserJoinTimeout WinState = 1
	WinState_OtherDisconn    WinState = 2
	WinState_OtherQuit       WinState = 3
	WinState_DRAW            WinState = 4
	WinState_ServerShutdown  WinState = 5
	WinState_GameTimeout     WinState = 6
)

var WinState_name = map[int32]string{
	0: "NormalFinish",
	1: "UserJoinTimeout",
	2: "OtherDisconn",
	3: "OtherQuit",
	4: "DRAW",
	5: "ServerShutdown",
	6: "GameTimeout",
}

var WinState_value = map[string]int32{
	"NormalFinish":    0,
	"UserJoinTimeout": 1,
	"OtherDisconn":    2,
	"OtherQuit":       3,
	"DRAW":            4,
	"ServerShutdown":  5,
	"GameTimeout":     6,
}

func (x WinState) String() string {
	return proto.EnumName(WinState_name, int32(x))
}

func (WinState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{6}
}

// 数据协议，所有接受和发送的数据包都以Packet作为数据协议
type Packet struct {
	Uri                  int32    `protobuf:"varint,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Body                 []byte   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Packet) Reset()         { *m = Packet{} }
func (m *Packet) String() string { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()    {}
func (*Packet) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{0}
}
func (m *Packet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet.Merge(m, src)
}
func (m *Packet) XXX_Size() int {
	return m.Size()
}
func (m *Packet) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet.DiscardUnknown(m)
}

var xxx_messageInfo_Packet proto.InternalMessageInfo

func (m *Packet) GetUri() int32 {
	if m != nil {
		return m.Uri
	}
	return 0
}

func (m *Packet) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type EmojiInfo struct {
	Uid                  int64     `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	EmojiId              int32     `protobuf:"varint,2,opt,name=emojiId,proto3" json:"emojiId,omitempty"`
	EmojiType            EmojiType `protobuf:"varint,3,opt,name=emojiType,proto3,enum=pbtruco.EmojiType" json:"emojiType,omitempty"`
	EmojiText            string    `protobuf:"bytes,4,opt,name=emojiText,proto3" json:"emojiText,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EmojiInfo) Reset()         { *m = EmojiInfo{} }
func (m *EmojiInfo) String() string { return proto.CompactTextString(m) }
func (*EmojiInfo) ProtoMessage()    {}
func (*EmojiInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{1}
}
func (m *EmojiInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmojiInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmojiInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmojiInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmojiInfo.Merge(m, src)
}
func (m *EmojiInfo) XXX_Size() int {
	return m.Size()
}
func (m *EmojiInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EmojiInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EmojiInfo proto.InternalMessageInfo

func (m *EmojiInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *EmojiInfo) GetEmojiId() int32 {
	if m != nil {
		return m.EmojiId
	}
	return 0
}

func (m *EmojiInfo) GetEmojiType() EmojiType {
	if m != nil {
		return m.EmojiType
	}
	return EmojiType_Emoticon
}

func (m *EmojiInfo) GetEmojiText() string {
	if m != nil {
		return m.EmojiText
	}
	return ""
}

type PlayerInfo struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	AvatarUrl            string   `protobuf:"bytes,3,opt,name=avatarUrl,proto3" json:"avatarUrl,omitempty"`
	Sex                  int32    `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Ai                   bool     `protobuf:"varint,5,opt,name=ai,proto3" json:"ai,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerInfo) Reset()         { *m = PlayerInfo{} }
func (m *PlayerInfo) String() string { return proto.CompactTextString(m) }
func (*PlayerInfo) ProtoMessage()    {}
func (*PlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{2}
}
func (m *PlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerInfo.Merge(m, src)
}
func (m *PlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerInfo proto.InternalMessageInfo

func (m *PlayerInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *PlayerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerInfo) GetAvatarUrl() string {
	if m != nil {
		return m.AvatarUrl
	}
	return ""
}

func (m *PlayerInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *PlayerInfo) GetAi() bool {
	if m != nil {
		return m.Ai
	}
	return false
}

type PlayerInfoRsp struct {
	Players              []*PlayerInfo `protobuf:"bytes,1,rep,name=players,proto3" json:"players,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PlayerInfoRsp) Reset()         { *m = PlayerInfoRsp{} }
func (m *PlayerInfoRsp) String() string { return proto.CompactTextString(m) }
func (*PlayerInfoRsp) ProtoMessage()    {}
func (*PlayerInfoRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{3}
}
func (m *PlayerInfoRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerInfoRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerInfoRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerInfoRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerInfoRsp.Merge(m, src)
}
func (m *PlayerInfoRsp) XXX_Size() int {
	return m.Size()
}
func (m *PlayerInfoRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerInfoRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerInfoRsp proto.InternalMessageInfo

func (m *PlayerInfoRsp) GetPlayers() []*PlayerInfo {
	if m != nil {
		return m.Players
	}
	return nil
}

// 上报加载进度
type LoadingReq struct {
	Progress             int32    `protobuf:"varint,1,opt,name=progress,proto3" json:"progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadingReq) Reset()         { *m = LoadingReq{} }
func (m *LoadingReq) String() string { return proto.CompactTextString(m) }
func (*LoadingReq) ProtoMessage()    {}
func (*LoadingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{4}
}
func (m *LoadingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadingReq.Merge(m, src)
}
func (m *LoadingReq) XXX_Size() int {
	return m.Size()
}
func (m *LoadingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadingReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoadingReq proto.InternalMessageInfo

func (m *LoadingReq) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// 其他玩家的加载进度
type LoadingRsp struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Progress             int32    `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadingRsp) Reset()         { *m = LoadingRsp{} }
func (m *LoadingRsp) String() string { return proto.CompactTextString(m) }
func (*LoadingRsp) ProtoMessage()    {}
func (*LoadingRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{5}
}
func (m *LoadingRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadingRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadingRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadingRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadingRsp.Merge(m, src)
}
func (m *LoadingRsp) XXX_Size() int {
	return m.Size()
}
func (m *LoadingRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadingRsp.DiscardUnknown(m)
}

var xxx_messageInfo_LoadingRsp proto.InternalMessageInfo

func (m *LoadingRsp) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LoadingRsp) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

type BindRsp struct {
	Code                 RetCode  `protobuf:"varint,1,opt,name=code,proto3,enum=pbtruco.RetCode" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BindRsp) Reset()         { *m = BindRsp{} }
func (m *BindRsp) String() string { return proto.CompactTextString(m) }
func (*BindRsp) ProtoMessage()    {}
func (*BindRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{6}
}
func (m *BindRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BindRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BindRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BindRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindRsp.Merge(m, src)
}
func (m *BindRsp) XXX_Size() int {
	return m.Size()
}
func (m *BindRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_BindRsp.DiscardUnknown(m)
}

var xxx_messageInfo_BindRsp proto.InternalMessageInfo

func (m *BindRsp) GetCode() RetCode {
	if m != nil {
		return m.Code
	}
	return RetCode_SUCCESS
}

func (m *BindRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type HeartbeatReq struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartbeatReq) Reset()         { *m = HeartbeatReq{} }
func (m *HeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*HeartbeatReq) ProtoMessage()    {}
func (*HeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{7}
}
func (m *HeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatReq.Merge(m, src)
}
func (m *HeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatReq proto.InternalMessageInfo

func (m *HeartbeatReq) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type HeartbeatRsp struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartbeatRsp) Reset()         { *m = HeartbeatRsp{} }
func (m *HeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*HeartbeatRsp) ProtoMessage()    {}
func (*HeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{8}
}
func (m *HeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatRsp.Merge(m, src)
}
func (m *HeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatRsp proto.InternalMessageInfo

func (m *HeartbeatRsp) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type KickRsp struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KickRsp) Reset()         { *m = KickRsp{} }
func (m *KickRsp) String() string { return proto.CompactTextString(m) }
func (*KickRsp) ProtoMessage()    {}
func (*KickRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{9}
}
func (m *KickRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KickRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KickRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KickRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickRsp.Merge(m, src)
}
func (m *KickRsp) XXX_Size() int {
	return m.Size()
}
func (m *KickRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_KickRsp.DiscardUnknown(m)
}

var xxx_messageInfo_KickRsp proto.InternalMessageInfo

func (m *KickRsp) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *KickRsp) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type GameFailedRsp struct {
	RoomId               int32    `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameFailedRsp) Reset()         { *m = GameFailedRsp{} }
func (m *GameFailedRsp) String() string { return proto.CompactTextString(m) }
func (*GameFailedRsp) ProtoMessage()    {}
func (*GameFailedRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{10}
}
func (m *GameFailedRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameFailedRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameFailedRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameFailedRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameFailedRsp.Merge(m, src)
}
func (m *GameFailedRsp) XXX_Size() int {
	return m.Size()
}
func (m *GameFailedRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GameFailedRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GameFailedRsp proto.InternalMessageInfo

func (m *GameFailedRsp) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *GameFailedRsp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("pbtruco.PacketType", PacketType_name, PacketType_value)
	proto.RegisterEnum("pbtruco.ResponseType", ResponseType_name, ResponseType_value)
	proto.RegisterEnum("pbtruco.RetCode", RetCode_name, RetCode_value)
	proto.RegisterEnum("pbtruco.Uri", Uri_name, Uri_value)
	proto.RegisterEnum("pbtruco.ReconnState", ReconnState_name, ReconnState_value)
	proto.RegisterEnum("pbtruco.EmojiType", EmojiType_name, EmojiType_value)
	proto.RegisterEnum("pbtruco.WinState", WinState_name, WinState_value)
	proto.RegisterType((*Packet)(nil), "pbtruco.Packet")
	proto.RegisterType((*EmojiInfo)(nil), "pbtruco.EmojiInfo")
	proto.RegisterType((*PlayerInfo)(nil), "pbtruco.PlayerInfo")
	proto.RegisterType((*PlayerInfoRsp)(nil), "pbtruco.PlayerInfoRsp")
	proto.RegisterType((*LoadingReq)(nil), "pbtruco.LoadingReq")
	proto.RegisterType((*LoadingRsp)(nil), "pbtruco.LoadingRsp")
	proto.RegisterType((*BindRsp)(nil), "pbtruco.BindRsp")
	proto.RegisterType((*HeartbeatReq)(nil), "pbtruco.HeartbeatReq")
	proto.RegisterType((*HeartbeatRsp)(nil), "pbtruco.HeartbeatRsp")
	proto.RegisterType((*KickRsp)(nil), "pbtruco.KickRsp")
	proto.RegisterType((*GameFailedRsp)(nil), "pbtruco.GameFailedRsp")
}

func init() { proto.RegisterFile("base.proto", fileDescriptor_db1b6b0986796150) }

var fileDescriptor_db1b6b0986796150 = []byte{
	// 1062 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xce, 0xf8, 0x6f, 0xec, 0x8a, 0xe3, 0x74, 0x3a, 0xd9, 0xac, 0x59, 0x56, 0x91, 0x65, 0x21,
	0x61, 0x59, 0x60, 0x20, 0x7b, 0x02, 0x09, 0x24, 0x27, 0x99, 0x24, 0x26, 0x5e, 0xcf, 0x6c, 0x8f,
	0xad, 0x68, 0x4f, 0x56, 0xdb, 0x6e, 0x9c, 0xc1, 0x99, 0xe9, 0xf1, 0x4c, 0x4f, 0xd8, 0x1c, 0x39,
	0xc1, 0x4b, 0xf0, 0x3e, 0x1c, 0x79, 0x04, 0x94, 0x13, 0xff, 0x3f, 0x12, 0x0f, 0x80, 0xba, 0xdd,
	0x1e, 0x3b, 0x4b, 0xd0, 0xde, 0xba, 0xbf, 0xfa, 0xaa, 0xea, 0xab, 0xea, 0x2a, 0x35, 0xc0, 0x88,
	0xc6, 0xac, 0x15, 0x46, 0x5c, 0x70, 0x6c, 0x86, 0x23, 0x11, 0x25, 0x63, 0x5e, 0x6f, 0x41, 0xc1,
	0xa1, 0xe3, 0x19, 0x13, 0x18, 0x41, 0x36, 0x89, 0xbc, 0xaa, 0x51, 0x33, 0x1a, 0x79, 0x22, 0x8f,
	0x18, 0x43, 0x6e, 0xc4, 0x27, 0xb7, 0xd5, 0x4c, 0xcd, 0x68, 0x94, 0x89, 0x3a, 0xd7, 0xbf, 0x31,
	0xa0, 0x64, 0xf9, 0xfc, 0x4b, 0xaf, 0x13, 0x7c, 0xc1, 0x95, 0x8f, 0x37, 0x51, 0x3e, 0x59, 0x22,
	0x8f, 0xb8, 0x0a, 0x26, 0x53, 0xe6, 0x89, 0x72, 0xcb, 0x93, 0xe5, 0x15, 0x7f, 0x08, 0x25, 0x75,
	0xec, 0xdf, 0x86, 0xac, 0x9a, 0xad, 0x19, 0x8d, 0xca, 0x21, 0x6e, 0x69, 0x19, 0x2d, 0x6b, 0x69,
	0x21, 0x2b, 0x12, 0x7e, 0xba, 0xf4, 0x60, 0xaf, 0x44, 0x35, 0x57, 0x33, 0x1a, 0x25, 0xb2, 0x02,
	0xea, 0x11, 0x80, 0x73, 0x4d, 0x6f, 0x59, 0xf4, 0x3f, 0x4a, 0x30, 0xe4, 0x02, 0xea, 0x33, 0x25,
	0xa3, 0x44, 0xd4, 0x59, 0x46, 0xa4, 0x37, 0x54, 0xd0, 0x68, 0x10, 0x5d, 0x2b, 0x0d, 0x25, 0xb2,
	0x02, 0x64, 0x8c, 0x98, 0xbd, 0x52, 0x99, 0xf2, 0x44, 0x1e, 0x71, 0x05, 0x32, 0xd4, 0xab, 0xe6,
	0x6b, 0x46, 0xa3, 0x48, 0x32, 0xd4, 0xab, 0x7f, 0x06, 0x5b, 0xab, 0x9c, 0x24, 0x0e, 0xf1, 0xfb,
	0x60, 0x86, 0x0a, 0x88, 0xab, 0x46, 0x2d, 0xdb, 0xd8, 0x3c, 0xdc, 0x4d, 0x4b, 0x5a, 0x23, 0x2e,
	0x39, 0xf5, 0x06, 0x40, 0x97, 0xd3, 0x89, 0x17, 0x4c, 0x09, 0x9b, 0xe3, 0x27, 0x50, 0x0c, 0x23,
	0x3e, 0x8d, 0x58, 0x1c, 0xeb, 0xb6, 0xa7, 0xf7, 0xfa, 0x27, 0x2b, 0x66, 0x1c, 0x3e, 0x50, 0xdd,
	0xba, 0x6f, 0xe6, 0x35, 0xdf, 0x36, 0x98, 0x47, 0x5e, 0x30, 0x91, 0x8e, 0xef, 0x40, 0x6e, 0xcc,
	0x27, 0x4c, 0x79, 0x56, 0x0e, 0x51, 0x2a, 0x8e, 0x30, 0x71, 0xcc, 0x27, 0x8c, 0x28, 0xab, 0x0c,
	0xef, 0xc7, 0x53, 0xdd, 0x29, 0x79, 0xac, 0xbf, 0x07, 0xe5, 0x73, 0x46, 0x23, 0x31, 0x62, 0x54,
	0x48, 0xa9, 0x4f, 0xa1, 0x24, 0x3c, 0x9f, 0xc5, 0x82, 0xfa, 0xa1, 0x96, 0xb1, 0x02, 0xee, 0xb3,
	0xe3, 0xf0, 0x0d, 0xec, 0x67, 0x60, 0x5e, 0x78, 0xe3, 0xd9, 0xc3, 0x75, 0xed, 0x43, 0x21, 0x62,
	0x34, 0xe6, 0x81, 0x56, 0xa3, 0x6f, 0xf5, 0x36, 0x6c, 0x9d, 0x51, 0x9f, 0x9d, 0x52, 0xef, 0x9a,
	0xa9, 0xca, 0x24, 0x91, 0x73, 0xbf, 0x33, 0xd1, 0xad, 0xd3, 0x37, 0x39, 0x80, 0x3e, 0x8b, 0x63,
	0x3a, 0x5d, 0xbe, 0xfc, 0xf2, 0xda, 0xfc, 0x08, 0x60, 0x31, 0xea, 0x6a, 0xb8, 0x10, 0x94, 0xfb,
	0x2f, 0x1d, 0x6b, 0x48, 0xac, 0x17, 0x03, 0xcb, 0xed, 0xa3, 0x0d, 0xbc, 0x03, 0x5b, 0x1a, 0x71,
	0x1d, 0xbb, 0xe7, 0x5a, 0xc8, 0x68, 0x7e, 0x00, 0x65, 0xc2, 0xe2, 0x90, 0x07, 0x31, 0xbb, 0xe7,
	0xe4, 0x0e, 0x8e, 0x8f, 0x2d, 0xd7, 0x45, 0x1b, 0x78, 0x0b, 0x4a, 0x0a, 0x39, 0x6d, 0x77, 0xba,
	0xc8, 0x68, 0x7e, 0x67, 0x80, 0xa9, 0x7b, 0x8b, 0x37, 0xc1, 0x5c, 0xf1, 0x30, 0x54, 0x2c, 0x42,
	0x86, 0xce, 0x45, 0xbf, 0xd3, 0xed, 0x5a, 0x67, 0xed, 0x2e, 0x32, 0xf0, 0x36, 0x6c, 0x4a, 0xac,
	0x67, 0x77, 0xed, 0xb3, 0x4e, 0x0f, 0x65, 0x64, 0xb0, 0x05, 0xe0, 0x0e, 0x8e, 0x50, 0x16, 0xef,
	0xc2, 0xb6, 0xbc, 0x12, 0xcb, 0xb1, 0xda, 0xfd, 0x05, 0x27, 0x87, 0xf7, 0x00, 0x49, 0xd0, 0xed,
	0x9c, 0xf5, 0x86, 0xcb, 0x50, 0x79, 0xfc, 0x08, 0x76, 0x14, 0xd5, 0xb6, 0x9f, 0x0f, 0x4f, 0x3b,
	0xbd, 0x8e, 0x7b, 0x6e, 0x9d, 0xa0, 0xc2, 0x32, 0xc3, 0xa0, 0x77, 0xd1, 0xb3, 0x2f, 0x7b, 0x68,
	0xdc, 0xfc, 0x27, 0x07, 0xd9, 0x41, 0xe4, 0xe1, 0x0a, 0x80, 0x33, 0x13, 0x7a, 0x4a, 0xd0, 0x86,
	0x4c, 0xe5, 0xcc, 0xc4, 0xfa, 0x23, 0x22, 0x43, 0x93, 0xf4, 0x5b, 0xa1, 0x8c, 0x6c, 0x90, 0x33,
	0x13, 0xab, 0xb1, 0x44, 0x59, 0xa9, 0xc6, 0x99, 0x89, 0x7b, 0x3b, 0x81, 0x72, 0x32, 0xad, 0x33,
	0x13, 0x6a, 0xa7, 0x25, 0x90, 0xc7, 0x6f, 0xc1, 0x23, 0x67, 0x26, 0xe4, 0x03, 0xba, 0x82, 0x46,
	0x22, 0x7d, 0x45, 0x54, 0xd0, 0x99, 0x53, 0x93, 0x04, 0x4d, 0x0d, 0x2e, 0xc2, 0xda, 0x89, 0x02,
	0x8b, 0x3a, 0xbd, 0x64, 0x5e, 0x7a, 0x81, 0x84, 0x4a, 0x3a, 0xbd, 0x72, 0xf6, 0xa6, 0x81, 0x15,
	0x45, 0x3c, 0x42, 0xb0, 0x16, 0xd2, 0xe1, 0x33, 0x16, 0x49, 0xea, 0x26, 0x7e, 0x0c, 0xbb, 0x69,
	0x48, 0xc2, 0xba, 0x7c, 0xba, 0x88, 0x51, 0xc6, 0x55, 0xd8, 0x4b, 0x0d, 0xed, 0xc9, 0x24, 0x75,
	0xd9, 0xba, 0x67, 0xb1, 0x13, 0x91, 0x5a, 0x2a, 0xf8, 0x09, 0xec, 0x2f, 0xf3, 0x26, 0xe3, 0x31,
	0x8b, 0xe3, 0xd4, 0xb6, 0xad, 0x13, 0x49, 0x5b, 0x9f, 0xce, 0x56, 0x0a, 0x90, 0x7c, 0x23, 0x6d,
	0x38, 0x4f, 0x52, 0x78, 0x07, 0xef, 0xbd, 0xd6, 0x7a, 0x36, 0x47, 0x3f, 0x99, 0x18, 0xdf, 0xeb,
	0x35, 0x9b, 0xa3, 0x9f, 0x4d, 0xbc, 0xad, 0xde, 0xe3, 0x45, 0xe2, 0x29, 0xd2, 0x2f, 0x26, 0x46,
	0x6b, 0x7d, 0x66, 0x73, 0xf4, 0xab, 0x6c, 0x5c, 0x45, 0xe7, 0xb0, 0x6f, 0x64, 0x9d, 0x73, 0xf4,
	0x9b, 0x89, 0x1f, 0x03, 0xd6, 0x60, 0x5a, 0x1f, 0x9b, 0xa3, 0xdf, 0x4d, 0x5c, 0x4d, 0xa5, 0x2e,
	0xca, 0x13, 0x0b, 0xcb, 0x1f, 0x26, 0x7e, 0xfb, 0xe1, 0x02, 0xd9, 0x1c, 0xfd, 0xb9, 0xee, 0xb6,
	0xaa, 0x90, 0xcd, 0xd1, 0x5f, 0x26, 0xde, 0xff, 0x4f, 0x89, 0x6c, 0x8e, 0xfe, 0x36, 0x9b, 0x9f,
	0xc2, 0x26, 0x61, 0x63, 0x1e, 0x04, 0xae, 0xa0, 0x82, 0xe1, 0x12, 0xe4, 0x7b, 0xf6, 0xc0, 0xb5,
	0x16, 0x4b, 0xd7, 0xb3, 0x87, 0x4e, 0xb7, 0xfd, 0xd2, 0x22, 0xdd, 0x8e, 0xdb, 0x47, 0x86, 0x5c,
	0xb2, 0x9e, 0x3d, 0x3c, 0x6b, 0x3f, 0xb7, 0xdc, 0x7e, 0x9b, 0xf4, 0x51, 0xa6, 0xf9, 0xb1, 0xfe,
	0x73, 0xd4, 0x0e, 0x96, 0xa1, 0x68, 0xf9, 0x5c, 0x78, 0x63, 0x1e, 0xa0, 0x0d, 0x39, 0x6a, 0x84,
	0x4d, 0x93, 0x6b, 0x1a, 0xc9, 0x4f, 0x01, 0x19, 0x72, 0x87, 0x3a, 0x41, 0x98, 0x08, 0x75, 0xcd,
	0x34, 0xbf, 0x36, 0xa0, 0x78, 0xe9, 0xe9, 0xbc, 0x32, 0x32, 0x8f, 0x7c, 0x7a, 0x7d, 0xea, 0x05,
	0x5e, 0x7c, 0xb5, 0x98, 0xfb, 0x41, 0xcc, 0xa2, 0xcf, 0xb9, 0x17, 0xf4, 0x3d, 0x9f, 0xf1, 0x44,
	0x2c, 0x04, 0xd8, 0xe2, 0x8a, 0x45, 0x27, 0x5e, 0x2c, 0x35, 0x2f, 0x16, 0x53, 0x21, 0xb2, 0xf7,
	0x28, 0x8b, 0x8b, 0x90, 0x3b, 0x21, 0xed, 0x4b, 0x94, 0x93, 0x6b, 0xed, 0xb2, 0xe8, 0x86, 0x45,
	0xee, 0x55, 0x22, 0x26, 0xfc, 0xab, 0x00, 0xe5, 0xa5, 0x24, 0xd5, 0x1b, 0x1d, 0xaf, 0x70, 0xf4,
	0xee, 0xf7, 0x77, 0x07, 0xc6, 0x0f, 0x77, 0x07, 0xc6, 0x8f, 0x77, 0x07, 0x06, 0xec, 0x8d, 0xb9,
	0xdf, 0xba, 0x4a, 0x6e, 0x69, 0xeb, 0x6a, 0x3c, 0x6d, 0x4d, 0xa9, 0xcf, 0x5a, 0xe1, 0xc8, 0x31,
	0xbe, 0x35, 0x8c, 0x51, 0x41, 0x7d, 0xce, 0xcf, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x99, 0xed,
	0x00, 0x8b, 0xaa, 0x07, 0x00, 0x00,
}

func (m *Packet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uri != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Uri))
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EmojiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmojiInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Uid))
	}
	if m.EmojiId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.EmojiId))
	}
	if m.EmojiType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.EmojiType))
	}
	if len(m.EmojiText) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.EmojiText)))
		i += copy(dAtA[i:], m.EmojiText)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.AvatarUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.AvatarUrl)))
		i += copy(dAtA[i:], m.AvatarUrl)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Sex))
	}
	if m.Ai {
		dAtA[i] = 0x28
		i++
		if m.Ai {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayerInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Progress != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Progress))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadingRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadingRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Uid))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Progress))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BindRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KickRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Uid))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameFailedRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameFailedRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBase(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Packet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uri != 0 {
		n += 1 + sovBase(uint64(m.Uri))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmojiInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBase(uint64(m.Uid))
	}
	if m.EmojiId != 0 {
		n += 1 + sovBase(uint64(m.EmojiId))
	}
	if m.EmojiType != 0 {
		n += 1 + sovBase(uint64(m.EmojiType))
	}
	l = len(m.EmojiText)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBase(uint64(m.Uid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.AvatarUrl)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovBase(uint64(m.Sex))
	}
	if m.Ai {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerInfoRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Progress != 0 {
		n += 1 + sovBase(uint64(m.Progress))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadingRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBase(uint64(m.Uid))
	}
	if m.Progress != 0 {
		n += 1 + sovBase(uint64(m.Progress))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BindRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBase(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovBase(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovBase(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KickRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBase(uint64(m.Uid))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameFailedRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovBase(uint64(m.RoomId))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBase(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBase(x uint64) (n int) {
	return sovBase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Packet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Packet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Packet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			m.Uri = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uri |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmojiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmojiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmojiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiId", wireType)
			}
			m.EmojiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmojiId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiType", wireType)
			}
			m.EmojiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmojiType |= EmojiType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmojiText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ai", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ai = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &PlayerInfo{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadingRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadingRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadingRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= RetCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameFailedRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameFailedRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameFailedRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBase
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBase
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBase
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBase(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBase
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBase = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBase   = fmt.Errorf("proto: integer overflow")
)
